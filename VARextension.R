#######################################FUNCTIONS#######################################

#######################################VARcompare######################################
# Uses VARselect from the vars package to select which type of VAR model to choose
# Arguments:
#   x: Object of class 'varest'; generated by VAR().
#   m: Integer of the desired lag.max for VARselect function. Default is 10.
# Output:
#   String, the 4 output types is: "both", "trend", "const", "none"
#######################################################################################

VARcompare <- function(x, m=NULL){
  test <- vector("list", 4)
  choice <- c("both", "trend", "const", "none")
  if(is.null(m)){
    test[[1]]<-VARselect(x, lag.max=10, type=choice[1])
    test[[2]]<-VARselect(x, lag.max=10, type=choice[2])
    test[[3]]<-VARselect(x, lag.max=10, type=choice[3])
    test[[4]]<-VARselect(x, lag.max=10, type=choice[4])
  }else{
    test[[1]]<-VARselect(x, lag.max=m, type=choice[1])
    test[[2]]<-VARselect(x, lag.max=m, type=choice[2])
    test[[3]]<-VARselect(x, lag.max=m, type=choice[3])
    test[[4]]<-VARselect(x, lag.max=m, type=choice[4])
  }
  best<-which.min(c(min(test[[1]]$criteria), min(test[[2]]$criteria), 
                    min(test[[3]]$criteria), min(test[[4]]$criteria)))
  return(choice[best])
}


#######################################VARcompare######################################
# Modified restrict function from the vars package.
# All credit goes to the creators of the vars package: 
#   Bernhard Pfaff [aut, cre], Matthieu Stigler [ctb]
#
# Changes:
#   This modified version does not stop when no significant regressors are found
#   It also prints an alternative warning, when only 1 regressor is found.
# Arguments:
#   m: Integer which indicates the model used (beneficial in loops)
#   For other arguements a detailed arguments description can be found in the original
#   restrict function
# Output:
#   See original restrict function.
#######################################################################################
restrict2 <- function(x, method = c("ser", "manual"), thresh = 2, resmat = NULL, m=NULL) 
{
  if (!(class(x) == "varest")) {
    stop("\nPlease provide an object of class 'varest', generated by 'var()'.\n")
  }
  method <- match.arg(method)
  K <- x$K
  p <- x$p
  datasub <- x$datamat[, -c(1:K)]
  namesall <- colnames(datasub)
  yendog <- x$datamat[, c(1:K)]
  sample <- x$obs
  ser <- function(x, y) {
    tvals <- abs(coef(summary(x))[, 3])
    datares <- datasub
    if (min(tvals) >= thresh) {
      lmres <- x
      datares <- datasub
    }
    else {
      while (min(tvals) < thresh) {
        if (ncol(datares) > 1) {
          cnames <- colnames(datares)
          datares <- as.data.frame(datares[, -1 * which.min(tvals)])
          colnames(datares) <- cnames[-1 * which.min(tvals)]
          lmres <- lm(y ~ -1 + ., data = datares)
          tvals <- abs(coef(summary(lmres))[, 3])
        }
        else {
          #Change here to stop if ncol(datares)==1
          #lmres <- NULL
          #datares <- as.data.frame(datares[, -1 * which.min(tvals)])
          break
        }
      }
    }
    return(list(lmres = lmres, datares = datares))
  }
  if (method == "ser") {
    x$restrictions <- matrix(0, nrow = K, ncol = ncol(datasub))
    colnames(x$restrictions) <- namesall
    rownames(x$restrictions) <- colnames(yendog)
    for (i in 1:K) {
      temp <- ser(x$varresult[[i]], yendog[, i])
      if (ncol(temp$datares)==1 & is.null(m)) {
        #Removing stop criteria and replace with warning.
        warning(paste("Certain regressors in", colnames(yendog)[i], 
                      "for model", m,  "might be insignificant.\n"))
      }
      x$varresult[[i]] <- temp[[1]]
      namessub <- colnames(temp[[2]])
      x$restrictions[i, namesall %in% namessub] <- 1
    }
  }
  else if (method == "manual") {
    resmat <- as.matrix(resmat)
    if (!(nrow(resmat) == K) | !(ncol(resmat) == ncol(datasub))) {
      stop(paste("\n Please provide resmat with dimensions:", 
                 K, "x", ncol(datasub), "\n"))
    }
    x$restrictions <- resmat
    colnames(x$restrictions) <- namesall
    rownames(x$restrictions) <- colnames(yendog)
    for (i in 1:K) {
      datares <- data.frame(datasub[, which(x$restrictions[i, 
                                                           ] == 1)])
      colnames(datares) <- colnames(datasub)[which(x$restrictions[i, 
                                                                  ] == 1)]
      y <- yendog[, i]
      lmres <- lm(y ~ -1 + ., data = datares)
      x$varresult[[i]] <- lmres
    }
  }
  return(x)
}


